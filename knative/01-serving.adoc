= Setting Up Knative on Minikube
:docinfo: shared

Setup Minikube to run Knative Serving

https://github.com/csantanapr/knative-minikube[Source: Carlos Santana knative-minikube]

TLDR;

----
minikube start
minikube tunnel
----

== Configure And Start Minikube

Versions used:
====
.At the time of writing June 2022
<1> Knative Serving 1.3.0
<2> Knative Kourier 1.3.0
<3> Knative Eventing 1.1.4
<4> Minikube 1.25.2
<5> Kubernetes 1.22.2
====

=== Configuration
Minikube Configuration
----
minikube config set cpus 6
minikube config set memory 16384
minikube config set kubernetes-version v1.22.2
minikube config set container-runtime containerd
----

=== Tools for Kubernetes

[NOTE]
All of the MacOS downloads are *amd* links.  If you have a newer Mac, link to the
releases for that tool.

[.stripes-even, %header, cols="1,1,1"]
|===
|*Tool* | *Mac* | *Fedora*
|Git
|https://git-scm.com/download/mac[Download]
|dnf install git
|kubectl
|https://storage.googleapis.com/kubernetes-release/release/v1.23.0/bin/darwin/amd64/kubectl[Download]
|https://storage.googleapis.com/kubernetes-release/release/v1.23.0/bin/linux/amd64/kubectl[Download]
|https://github.com/wercker/stern[stern]
|brew install stern
|Although you can install stern through a direct download, I have found, it will probably not work
correctly on Linux with minikube.  The easiest way to get it working is to install a kubectl
plugin called https://krew.sigs.k8s.io/docs/user-guide/setup/install/[krew] first.
Then install stern via krew:

kubectl krew install stern
|https://github.com/mikefarah/yq[yq]
|https://github.com/mikefarah/yq/releases/download/2.4.1/yq_darwin_amd64[Download]
|https://github.com/mikefarah/yq/releases/download/2.4.1/yq_linux_amd64[Download]
|https://httpie.org/[httpie]
|brew install httpie
|dnf install httpie
|https://github.com/rakyll/hey[hey]
|brew install hey
|https://hey-release.s3.us-east-2.amazonaws.com/hey_linux_amd64[Download]
|kubectx and kubens
|brew install kubectx
|https://github.com/ahmetb/kubectx[Can be downloaded as a bash script or as a plugin for krew]
|watch
|brew install watch
|dnf install procps-ng
|kapp
|
brew tap vmware-tanzu/carvel

 brew install kapp

 kapp version
| https://carvel.dev/kapp/docs/v0.49.0/install/[kapp install]
|ytt
|
brew tap vmware-tanzu/carvel

brew install ytt

ytt version
| https://carvel.dev/ytt/docs/v0.41.0/install/[ytt install]
|===

=== Clean And Check Minikube

If you want to make sure you are using a clean environment, you should first delete the VM:

----
minikube delete
----

If you aren't sure you are running the latest version of minikube:

----
minikube update-check
----

If you don't have the latest version of minikube and wish to update:

link:../upgrade/minikube-upgrade.sh[Update Minikube Bash Script]

=== Start Minikube
Now we can start minikube:
----
minikube start
----

Alternatively, we can use our local bash script:

file:///./bin/start-minikube.sh[Start minikube Bash Script]

After starting minikube, you will need an EXTERNAL-IP for Kourier.  In another terminal window:

----
minikube tunnel
----

=== Deploy Registry

----
minikube -p knativesandbox addons enable registry
----

== Install Knative Serving

[arabic, start=1]
. Set the version of Knative Serving. Latest versions listed above.
+
----
export KNATIVE_SERVING_VERSION="x.x.x"
----
. Install Knative Serving into namespace `knative-serving`
+
----
kubectl apply -f https://github.com/knative/serving/releases/download/knative-v${KNATIVE_VERSION}/serving-crds.yaml
kubectl wait --for=condition=Established --all crd

kubectl apply -f https://github.com/knative/serving/releases/download/knative-v${KNATIVE_VERSION}/serving-core.yaml

kubectl wait pod --timeout=-1s --for=condition=Ready -l '!job-name' -n knative-serving > /dev/null
----
. Select the version of Knative Net Kourier to install
+
----
 export KNATIVE_NET_KOURIER_VERSION="x.x.x"
----
. Install Knative Layer kourier in namespace `kourier-system`
+
----
kubectl apply -f https://github.com/knative/net-kourier/releases/download/knative-v${KNATIVE_NET_KOURIER_VERSION}/kourier.yaml

kubectl wait pod --timeout=-1s --for=condition=Ready -l '!job-name' -n kourier-system

kubectl wait pod --timeout=-1s --for=condition=Ready -l '!job-name' -n knative-serving
----
. Set the environment variable `EXTERNAL_IP` to External IP Address of the Worker Node, you might need to run this command multiple times until service is ready.
+
----
EXTERNAL_IP=$(kubectl -n kourier-system get service kourier -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
echo EXTERNAL_IP=$EXTERNAL_IP
----
. Set the environment variable `KNATIVE_DOMAIN` as the DNS domain using `nip.io`
.. Set the environment variable
+
----
KNATIVE_DOMAIN="$EXTERNAL_IP.nip.io"
echo KNATIVE_DOMAIN=$KNATIVE_DOMAIN
----

.. Double check DNS is resolving
+
----
dig $KNATIVE_DOMAIN
----

. Configure DNS for Knative Serving
+
----
kubectl patch configmap -n knative-serving config-domain -p "{\"data\": {\"$KNATIVE_DOMAIN\": \"\"}}"
----

. Configure Knative to use Kourier
+
----
kubectl patch configmap/config-network \
  --namespace knative-serving \
  --type merge \
  --patch '{"data":{"ingress.class":"kourier.ingress.networking.knative.dev"}}'
----

. Verify that Knative is Installed properly all pods should be in `Running` state and our `kourier-ingress` service configured.
+
----
kubectl get pods -n knative-serving
kubectl get pods -n kourier-system
kubectl get svc  -n kourier-system
----

=== Deploy Knative Serving Application

. Deploy a sample app
.. Using the https://github.com/knative/client[kn] client
+
----
kn service create hello \
--image gcr.io/knative-samples/helloworld-go \
--port 8080 \
--env TARGET=Knative
----

.. *Optional:* Deploy a Knative Service using the equivalent yaml manifest:
+
----
cat <<EOF | kubectl apply -f -
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: hello
spec:
  template:
    spec:
      containers:
        - image: gcr.io/knative-samples/helloworld-go
          ports:
            - containerPort: 8080
          env:
            - name: TARGET
              value: "Knative"
EOF
----

. Wait for Knative Service to be Ready
+
----
kubectl wait ksvc hello --all --timeout=-1s --for=condition=Ready
----

. Get the URL of the new Service
+
----
SERVICE_URL=$(kubectl get ksvc hello -o jsonpath='{.status.url}')
echo $SERVICE_URL
----

. Test the App
+
----
curl $SERVICE_URL
----
.. The output should be
+
----
Hello Knative!
----

. Check the knative pods that scaled from zero
+
----
kubectl get pod -l serving.knative.dev/service=hello
----

.. The output should be
+
----
NAME                                     READY   STATUS    RESTARTS   AGE
hello-r4vz7-deployment-c5d4b88f7-ks95l   2/2     Running   0          7s
----

.. Try the service `url` on your browser (command works on linux and macos)
+
----
open $SERVICE_URL
----

. You can watch the pods and see how they scale down to zero after http traffic stops to the url
+
----
kubectl get pod -l serving.knative.dev/service=hello -w
----

.. The output should look something like this
+
----
NAME                                     READY   STATUS
hello-r4vz7-deployment-c5d4b88f7-ks95l   2/2     Running
hello-r4vz7-deployment-c5d4b88f7-ks95l   2/2     Terminating
hello-r4vz7-deployment-c5d4b88f7-ks95l   1/2     Terminating
hello-r4vz7-deployment-c5d4b88f7-ks95l   0/2     Terminating
----

. If we try to access the url again, and you will see a new pod running again.
+
----
NAME                                     READY   STATUS
hello-r4vz7-deployment-c5d4b88f7-rr8cd   0/2     Pending
hello-r4vz7-deployment-c5d4b88f7-rr8cd   0/2     ContainerCreating
hello-r4vz7-deployment-c5d4b88f7-rr8cd   1/2     Running
hello-r4vz7-deployment-c5d4b88f7-rr8cd   2/2     Running
----

**We now have Knative Serving running!**
